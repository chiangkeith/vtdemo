{"version":3,"sources":["webpack:///./node_modules/truncate-html/dist/truncate.es.js","webpack:///./node_modules/string_decoder/lib/string_decoder.js","webpack:///./node_modules/safe-buffer/index.js"],"names":["cheerio__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","defaultOptions","stripTags","ellipsis","decodeEntities","byWords","excludes","reserveLastWord","keepWhitespaces","helper","setup","length","options","fullOptions","this","extend","Array","isArray","join","limit","obj","dft","k","v","isBlank","char","truncate","text","isLastNode","this$1","replace","str","strLen","idx","count","prevIsBlank","curIsBlank","charAt","substr","len","cutted","boundary","substring","test","result","maxExceeded","mtc","match","exceeded","isCheerioInstance","elem","contains","html","parseHTML","isNaN","Infinity","$","Object","$html","root","find","remove","travelChildren","$ele","isParentLastNode","contents","lastIdx","each","type","data","assign","__webpack_exports__","Buffer","isEncoding","encoding","toLowerCase","_normalizeEncoding","enc","retried","normalizeEncoding","nenc","Error","StringDecoder","nb","utf16Text","end","utf16End","fillLast","utf8FillLast","base64Text","base64End","write","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","allocUnsafe","utf8CheckByte","byte","utf8CheckIncomplete","self","buf","i","j","utf8CheckExtraBytes","p","r","undefined","copy","toString","utf8Text","total","utf8End","c","charCodeAt","slice","n","exports","prototype","buffer","copyProps","src","dst","key","SafeBuffer","arg","encodingOrOffset","from","alloc","allocUnsafeSlow","module","TypeError","size","fill","SlowBuffer"],"mappings":"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","file":"js/chunk-vendors~ec8c427e.38577846.js","sourcesContent":["/*!\n * trancate-html v1.0.1\n * CopyrightÂ© 2018 Saiya https://github.com/evecalm/truncate-html#readme\n */\nimport { load } from 'cheerio';\n\n// default options\r\nvar defaultOptions = {\r\n    // remove all tags\r\n    stripTags: false,\r\n    // postfix of the string\r\n    ellipsis: '...',\r\n    // decode html entities\r\n    decodeEntities: false,\r\n    // whether truncate by words\r\n    byWords: false,\r\n    // // truncate by words, set to true keep words\r\n    // // set to number then truncate by word count\r\n    // length: 0\r\n    excludes: '',\r\n    reserveLastWord: false,\r\n    keepWhitespaces: false // even if set true, continuous whitespace will count as one\r\n};\r\n// helper method\r\nvar helper = {\r\n    setup: function setup(length, options) {\r\n        switch (typeof length) {\r\n            case 'object':\r\n                options = length;\r\n                break;\r\n            case 'number':\r\n                if (typeof options === 'object') {\r\n                    options.length = length;\r\n                }\r\n                else {\r\n                    options = {\r\n                        length: length\r\n                    };\r\n                }\r\n        }\r\n        var fullOptions = this.extend(options, defaultOptions);\r\n        // if (typeof fullOptions.length !== 'number') throw new TypeError('truncate-html: options.length should be a number')\r\n        if (fullOptions.excludes) {\r\n            if (!Array.isArray(fullOptions.excludes)) {\r\n                fullOptions.excludes = [fullOptions.excludes];\r\n            }\r\n            fullOptions.excludes = fullOptions.excludes.join(',');\r\n        }\r\n        this.options = fullOptions;\r\n        this.limit = fullOptions.length;\r\n        this.ellipsis = fullOptions.ellipsis;\r\n        this.keepWhitespaces = fullOptions.keepWhitespaces;\r\n        this.reserveLastWord = fullOptions.reserveLastWord;\r\n    },\r\n    // extend obj with dft\r\n    extend: function extend(obj, dft) {\r\n        if (obj == null) {\r\n            obj = {};\r\n        }\r\n        for (var k in dft) {\r\n            var v = dft[k];\r\n            if (obj[k] != null) {\r\n                continue;\r\n            }\r\n            obj[k] = v;\r\n        }\r\n        return obj;\r\n    },\r\n    // test a char whether a whitespace char\r\n    isBlank: function isBlank(char) {\r\n        return (char === ' ' ||\r\n            char === '\\f' ||\r\n            char === '\\n' ||\r\n            char === '\\r' ||\r\n            char === '\\t' ||\r\n            char === '\\v' ||\r\n            char === '\\u00A0' ||\r\n            char === '\\u2028' ||\r\n            char === '\\u2029');\r\n    },\r\n    /**\r\n     * truncate text\r\n     * @param  {String}  text        text to truncate\r\n     * @param  {Boolean} isLastNode  is last dom node, help to decide whether add ellipsis\r\n     * @return {String}\r\n     */\r\n    truncate: function truncate(text, isLastNode) {\n        var this$1 = this;\n\r\n        if (!this.keepWhitespaces) {\r\n            text = text.replace(/\\s+/g, ' ');\r\n        }\r\n        var byWords = this.options.byWords;\r\n        var strLen = text.length;\r\n        var idx = 0;\r\n        var count = 0;\r\n        var prevIsBlank = byWords;\r\n        var curIsBlank = false;\r\n        while (idx < strLen) {\r\n            curIsBlank = this$1.isBlank(text.charAt(idx++));\r\n            // keep same then continue\r\n            if (byWords && prevIsBlank === curIsBlank)\r\n                { continue; }\r\n            if (count === this$1.limit) {\r\n                // reserve trailing whitespace\r\n                if (curIsBlank) {\r\n                    prevIsBlank = curIsBlank;\r\n                    continue;\r\n                }\r\n                // fix idx because current char belong to next words which exceed the limit\r\n                --idx;\r\n                break;\r\n            }\r\n            if (byWords) {\r\n                curIsBlank || ++count;\r\n            }\r\n            else {\r\n                (curIsBlank && prevIsBlank) || ++count;\r\n            }\r\n            prevIsBlank = curIsBlank;\r\n        }\r\n        this.limit -= count;\r\n        if (this.limit) {\r\n            return text;\r\n        }\r\n        else {\r\n            var str;\r\n            if (byWords) {\r\n                str = text.substr(0, idx);\r\n            }\r\n            else {\r\n                str = this.substr(text, idx);\r\n            }\r\n            if (str === text) {\r\n                // if is lat node, no need of ellipsis, or add it\r\n                return isLastNode ? text : text + this.ellipsis;\r\n            }\r\n            else {\r\n                return str + this.ellipsis;\r\n            }\r\n        }\r\n    },\r\n    // deal with cut string in the middle of a word\r\n    substr: function substr(str, len) {\r\n        // var boundary, cutted, result\r\n        var cutted = str.substr(0, len);\r\n        if (!this.reserveLastWord) {\r\n            return cutted;\r\n        }\r\n        var boundary = str.substring(len - 1, len + 1);\r\n        // if truncate at word boundary, just return\r\n        if (/\\W/.test(boundary)) {\r\n            return cutted;\r\n        }\r\n        if (this.reserveLastWord < 0) {\r\n            var result = cutted.replace(/\\w+$/, '');\r\n            // if the cutted is not the first and the only word\r\n            //   then return result, or return the whole word\r\n            if (!(result.length === 0 && cutted.length === this.options.length)) {\r\n                return result;\r\n            }\r\n        }\r\n        // set max exceeded to 10 if this.reserveLastWord is true or > 0\r\n        var maxExceeded = this.reserveLastWord !== true && this.reserveLastWord > 0\r\n            ? this.reserveLastWord\r\n            : 10;\r\n        var mtc = str.substr(len).match(/(\\w+)/);\r\n        var exceeded = mtc ? mtc[1] : '';\r\n        return cutted + exceeded.substr(0, maxExceeded);\r\n    }\r\n};\r\n/** return true if elem is CheerioStatic */\r\nfunction isCheerioInstance(elem) {\r\n    return elem &&\r\n        elem.contains &&\r\n        elem.html &&\r\n        elem.parseHTML && true;\r\n}\r\n/**\r\n * truncate html\r\n * @method truncate(html, [length], [options])\r\n * @param  {String}         html    html string to truncate\r\n * @param  {Object|number}  length how many letters(words if `byWords` is true) you want reserve\r\n * @param  {Object|null}    options\r\n * @return {String}\r\n */\r\nvar truncate = function (html, length, options) {\r\n    helper.setup(length, options);\r\n    if (!html ||\r\n        isNaN(helper.limit) ||\r\n        helper.limit <= 0 ||\r\n        helper.limit === Infinity) {\r\n        return html;\r\n    }\r\n    // if (helper.limit)\r\n    var $;\r\n    // support provied cheerio\r\n    if (isCheerioInstance(html)) {\r\n        $ = html;\r\n    }\r\n    else {\r\n        // Add a wrapper for text node without tag like:\r\n        //   <p>Lorem ipsum <p>dolor sit => <div><p>Lorem ipsum <p>dolor sit</div>\r\n        $ = load((\"\" + html), {\r\n            decodeEntities: helper.options.decodeEntities\r\n        });\r\n    }\r\n    var $html = $.root();\r\n    // remove excludes elements\r\n    helper.options.excludes && $html.find(helper.options.excludes).remove();\r\n    // strip tags and get pure text\r\n    if (helper.options.stripTags) {\r\n        return helper.truncate($html.text());\r\n    }\r\n    var travelChildren = function ($ele, isParentLastNode) {\n        if ( isParentLastNode === void 0 ) isParentLastNode = true;\n\r\n        var contents = $ele.contents();\r\n        var lastIdx = contents.length - 1;\r\n        return contents.each(function (idx) {\r\n            switch (this.type) {\r\n                case 'text':\r\n                    if (!helper.limit) {\r\n                        $(this).remove();\r\n                        return;\r\n                    }\r\n                    this.data = helper.truncate($(this).text(), isParentLastNode && idx === lastIdx);\r\n                    break;\r\n                case 'tag':\r\n                    if (!helper.limit) {\r\n                        $(this).remove();\r\n                    }\r\n                    else {\r\n                        return travelChildren($(this), isParentLastNode && idx === lastIdx);\r\n                    }\r\n                    break;\r\n                default:\r\n                    // for comments\r\n                    return $(this).remove();\r\n            }\r\n        });\r\n    };\r\n    travelChildren($html);\r\n    return $html.html();\r\n};\r\ntruncate.setup = function (options) {\n    if ( options === void 0 ) options = {};\n\r\n    return Object.assign(defaultOptions, options);\r\n};\n\nexport default truncate;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n"],"sourceRoot":""}